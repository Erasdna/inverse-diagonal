import numpy as np
from src.typealias import RealArray

def lanczos_decomposition(A: RealArray, x: RealArray, k: int):
    """lanczos method for finding orthogonal basis of krylov space generated by A and x

    Args:
        A (RealArray): Hermitian matrix
        x (RealArray): Vector to generate Krylov subspace
        k (int): Number of generated basis vectors is k + 1 
    """

    #TODO: Reorthogoninze
    alpha = []
    beta = []

    u_1 = x / np.linalg.norm(x)
    U = [u_1]
    
    for j in range(k + 1):
        u_j = U[-1]
        w = A @ u_j
        alpha.append(np.inner(u_j, w))
        u_tilde = w - alpha[-1] * u_j
        if beta:
            u_tilde -= U[-2] * beta[-1]
        beta.append(np.linalg.norm(u_tilde))
        U.append(u_tilde / beta[-1])
    return U, alpha, beta


def lanczos_decomposition_2(A: RealArray, x: RealArray, k: int):
    """lanczos method for finding orthogonal basis of krylov space generated by A and x

    Args:
        A (RealArray): Hermitian matrix
        x (RealArray): Vector to generate Krylov subspace
        k (int): Number of generated basis vectors is k + 1 
    """

    alpha_list = []
    beta_list = []

    U=np.zeros((x.shape[0],k)) # Temporary solution
    u = x / np.linalg.norm(x)
    U[:,0] = u.copy()
    
    for j in range(k - 1):
        z = A @ u
        alpha=np.inner(U[:,j], z)
        u = z - alpha * U[:,j]
        if beta_list:
            u -= U[:,j-1] * beta_list[-1]
        
        #Reorthogonalization
        print(j)
        alphas=U.T @ u
        u-=U @ alphas 
        alpha+=alphas[-1]
        
        #And again?
        alphas=U.T @ u
        u-=U @ alphas 
        alpha+=alphas[-1]
        
        alpha_list.append(alpha)
        
        beta_list.append(np.linalg.norm(u))
        u/=beta_list[-1]
        U[:,j+1]=u.copy()
    return U, alpha_list, beta_list

