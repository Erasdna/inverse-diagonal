import numpy as np
from src.typealias import RealArray
import scipy.sparse as sparse
from scipy.sparse.linalg import spsolve

def lanczos_estimate(G: RealArray,U : RealArray ,alpha : RealArray ,beta : RealArray ,k : int):
    """Calculates the estimate of the diagonal of a matrix A using the the matrix U from the Lanczos decomposition

    Args:
        G (RealArray): Preconditiner
        U (RealArray): Basis of the Krylov subspace
        alpha (RealArray): Diagonal of the Hessenberg matrix
        beta (RealArray): sub/super - diagonal of the Hessenberg matrix
        k (int): Lanczos iterations

    Returns:
        est_diag_l (RealArray): Estimate of the diagonal of the inverse of A
        W (RealArray) : auxillary matrix
    """
    V = np.array(U[:,:k])
    T = sparse.diags((alpha[:k], beta[:k-1], beta[:k-1]), (0, 1, -1))
    L = np.linalg.cholesky(T.todense())
    W = spsolve(L, spsolve(G.T, V).transpose()).transpose()
    est_diag_l = np.sum(W**2, axis=1)
    return est_diag_l, W
    
def lanczos_decomposition(A: RealArray, x: RealArray, k: int):    
    """lanczos method for finding orthogonal basis of krylov space generated by A and x

    Args:
        A (RealArray): Hermitian matrix
        x (RealArray): Vector to generate Krylov subspace
        k (int): Number of generated basis vectors is k + 1 
    """

    alpha_list = []
    beta_list = []

    U=np.zeros((x.shape[0],k)) # Temporary solution
    u = x / np.linalg.norm(x)
    U[:,0] = u.copy()
    
    for j in range(k - 1):
        z = A @ u
        alpha=np.inner(U[:,j], z)
        u = z - alpha * U[:,j]
        if beta_list:
            u -= U[:,j-1] * beta_list[-1]
        
        #Reorthogonalization
        alphas=U.T @ u
        u-=U @ alphas 
        alpha+=alphas[-1]
        
        alpha_list.append(alpha)
        
        beta_list.append(np.linalg.norm(u))
        u/=beta_list[-1]
        U[:,j+1]=u.copy()
    return U, alpha_list, beta_list
